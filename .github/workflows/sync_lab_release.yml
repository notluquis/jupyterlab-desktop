# -----------------------------------------------------------------------------
#  Workflow: Check for new JupyterLab releases
#
#  What it does
#  ------------
#  - Detects the latest stable JupyterLab release (vX.Y.Z).
#  - Bumps version files (via tbump) to X.Y.Z-1.
#  - If changes exist, installs JS/Conda deps and updates lock files.
#  - Pushes a branch "update-to-vX.Y.Z" and opens/updates a PR.
#
#  Auth model (important)
#  ----------------------
#  - Prefer a GitHub App token (the "Desktop Bot") if available in this repo.
#    This requires repo-level: vars.APP_ID and secrets.APP_PRIVATE_KEY.
#  - If unavailable (e.g., forks), fall back to default GITHUB_TOKEN
#    (github-actions[bot]) which can push to the fork.
#
#  Design choices
#  --------------
#  - macOS runner: use `macos-latest` (keeps us aligned with official runners).
#  - Python 3.13 for host tooling (you’re fine with the tarfile deprecation
#    warnings; this keeps us forward-compatible).
#  - Yarn: use plain `yarn install` (no --frozen-lockfile) to avoid failures
#    when lock and package.json drift; lock changes are captured in the PR.
#  - Micromamba instead of conda: faster and conda-forge-only by default.
#  - No node_modules caching (keeps things simple and avoids cross-run quirks);
#    Yarn cache is enabled via setup-node.
#
#  Safety rails
#  ------------
#  - No changes → no PR.
#  - If a PR for the same branch already exists, we just push updates and
#    (optionally) add a comment—no duplicate PRs.
# -----------------------------------------------------------------------------

name: Check for new JupyterLab releases

on:
  schedule:
    - cron: 30 17 * * *   # daily at 17:30 UTC
  workflow_dispatch:

# Repo-level permissions: keep minimal but sufficient for content + PR actions.
permissions:
  contents: write
  pull-requests: write

jobs:
  check_for_lab_updates:
    runs-on: macos-latest
    environment: sync

    # Required for actions/create-github-app-token (OIDC → GitHub App).
    permissions:
      id-token: write

    defaults:
      run:
        # Conda/mamba workflows benefit from a login shell (conda init hooks).
        shell: bash -el {0}

    steps:
      # -----------------------------------------------------------------------
      # 1) Try to obtain a GitHub App token (Desktop Bot). In forks this may
      #    fail; we continue and fall back to the default GITHUB_TOKEN.
      # -----------------------------------------------------------------------
      - name: Create Desktop Bot app token (if available)
        id: app-token
        uses: actions/create-github-app-token@v2
        continue-on-error: true
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      # -----------------------------------------------------------------------
      # 2) Checkout without persisting credentials, so we control *which* token
      #    is used for pushes (App token if present, else GITHUB_TOKEN).
      # -----------------------------------------------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      # -----------------------------------------------------------------------
      # 3) Bind 'origin' to the chosen token and set an explicit committer.
      # -----------------------------------------------------------------------
      - name: Configure git auth for pushes/PRs
        run: |
          set -eux
          TOKEN="${{ steps.app-token.outputs.token || github.token }}"
          if [ -n "${{ steps.app-token.outputs.token }}" ]; then
            echo "::notice title=Auth::Using Desktop Bot (GitHub App) token for pushes."
          else
            echo "::notice title=Auth::Using default GITHUB_TOKEN (github-actions[bot]) for pushes."
          fi
          git config user.name  "JupyterLab Desktop Bot"
          git config user.email "jupyterlab-bot@users.noreply.github.com"
          git remote set-url origin "https://x-access-token:${TOKEN}@github.com/${{ github.repository }}.git"

      # gh is preinstalled on macOS runners, but ensure it's present just in case.
      - name: Ensure GitHub CLI is available
        run: |
          set -eux
          command -v gh >/dev/null 2>&1 || brew install gh

      # -----------------------------------------------------------------------
      # 4) Host tooling: Python + tbump. You asked for Python 3.13 explicitly.
      # -----------------------------------------------------------------------
      - name: Set up Python (host tooling)
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Install Python tooling
        run: python -m pip install --upgrade pip tbump

      # -----------------------------------------------------------------------
      # 5) Node with Yarn cache enabled (setup-node caches Yarn’s cache dir).
      #    We *do not* cache node_modules to keep fewer moving parts.
      # -----------------------------------------------------------------------
      - name: Set up Node (with Yarn cache)
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'
          cache-dependency-path: '**/yarn.lock'

      # -----------------------------------------------------------------------
      # 6) Discover the latest stable JupyterLab release.
      #    Prefer the Desktop Bot App token if present (higher perms upstream).
      # -----------------------------------------------------------------------
      - name: Get latest JupyterLab version
        id: get-latest-jupyterlab-version
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token || github.token }}
          script: |
            const releases = await github.rest.repos.listReleases({
              owner: "jupyterlab",
              repo: "jupyterlab"
            });
            const latest = releases.data.find(
              r => r.tag_name?.startsWith('v') && !(r.draft || r.prerelease)
            );
            return latest ? latest.tag_name.substring(1) : '';
          result-encoding: string

      # -----------------------------------------------------------------------
      # 7) Bump to X.Y.Z-1 and detect whether anything changed.
      #    If package.json changed, we consider that “update available”.
      # -----------------------------------------------------------------------
      - name: Bump version and detect changes
        shell: bash
        run: |
          set -eux
          LATEST='${{ steps.get-latest-jupyterlab-version.outputs.result }}'
          echo "latest=${LATEST}" >> "$GITHUB_ENV"

          tbump --only-patch "${LATEST}-1" --non-interactive

          # If package.json changed, schedule the rest of the workflow.
          if [[ -n "$(git status --porcelain package.json)" ]]; then
            echo "update_available=true" >> "$GITHUB_ENV"
          fi

      # -----------------------------------------------------------------------
      # 8) Install JS deps only when an update is needed.
      #    No --frozen-lockfile: allow Yarn to refresh yarn.lock if needed.
      # -----------------------------------------------------------------------
      - name: Install npm dependencies (Yarn)
        if: env.update_available == 'true'
        run: |
          set -eux
          npm install --global yarn
          yarn install

      # -----------------------------------------------------------------------
      # 9) Micromamba (fast conda). conda-forge only; cache downloads enabled.
      #    We install conda-lock in base so the CLI is available.
      # -----------------------------------------------------------------------
      - name: Set up micromamba (conda-forge only)
        if: env.update_available == 'true'
        uses: mamba-org/setup-micromamba@v1
        with:
          micromamba-version: 'latest'
          init-shell: bash
          channels: conda-forge
          condarc: |
            channel_priority: strict
            channels:
              - conda-forge
          cache-downloads: true
          cache-environment: false

      - name: Install conda-lock CLI
        if: env.update_available == 'true'
        run: micromamba install -y -n base -c conda-forge conda-lock

      # -----------------------------------------------------------------------
      # 10) Update the conda lock files and refresh the binary sign lists.
      #     Use --mamba so conda-lock drives micromamba, not classic conda.
      # -----------------------------------------------------------------------
      - name: Update conda lock files
        if: env.update_available == 'true'
        run: yarn update_conda_lock

      - name: Update binary sign list osx-64
        if: env.update_available == 'true'
        run: |
          set -eux
          yarn clean_env_installer
          conda-lock install --mamba --no-validate-platform \
            --prefix ./env_installer/jlab_server \
            ./env_installer/conda-osx-64.lock
          yarn update_binary_sign_list --platform osx-64

      - name: Update binary sign list osx-arm64
        if: env.update_available == 'true'
        run: |
          set -eux
          yarn clean_env_installer
          conda-lock install --mamba --no-validate-platform \
            --prefix ./env_installer/jlab_server \
            ./env_installer/conda-osx-arm64.lock
          yarn update_binary_sign_list --platform osx-arm64

      # -----------------------------------------------------------------------
      # 11) Create or update the PR. Idempotent:
      #     - No changes → exit early (no PR).
      #     - If PR for the branch exists → push updates and comment.
      #     - Else → create a new PR with gh CLI.
      # -----------------------------------------------------------------------
      - name: Open or update PR
        if: env.update_available == 'true'
        shell: bash
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token || github.token }}
        run: |
          set -eux
          LATEST='${{ env.latest }}'
          BRANCH="update-to-v${LATEST}"

          # Create/reuse the branch without failing if it already exists
          git fetch origin "${BRANCH}" || true
          git checkout -B "${BRANCH}"

          # Stage/commit only when there are actual changes
          git add -A
          if git diff --cached --quiet; then
            echo "No staged changes; nothing to commit."
            exit 0
          else
            git commit -m "Update to JupyterLab v${LATEST}"
          fi

          # Push using the token-bound origin
          git push --set-upstream origin "${BRANCH}"

          # If a PR is already open for this branch, just comment; else create a new PR.
          PR_NUMBER="$(gh pr list --head "${BRANCH}" --state open --json number --jq '.[0].number' || true)"
          if [ -n "${PR_NUMBER}" ]; then
            echo "::notice title=PR::Existing PR #${PR_NUMBER} detected; pushing updates only."
            gh pr comment "${PR_NUMBER}" --body "Automated update: refreshed lock files and metadata." || true
          else
            echo "::notice title=PR::Creating a new PR for ${BRANCH}."
            gh pr create \
              --title "Update to JupyterLab v${LATEST}" \
              --body  "New JupyterLab release [v${LATEST}](https://github.com/jupyterlab/jupyterlab/releases/tag/v${LATEST}) is available. Please review the lock files carefully." \
              --fill
          fi
